<meta charset="utf-8">
<div id="main"></div>
<link href="https://fonts.googleapis.com/css?family=Lato:400,900" rel="stylesheet">
<style>
@keyframes up4px { to { transform: translatey(-4px);} }
body { background-color: rgb(125, 119, 168); }

/* This selects the *parent* of the speech bubble div (which is a "helper"
   div that style-elments injects, hence this rule's presence in HTML-land).
   It sets that elements' margin rules so that the speech bubble overflows
   *downward* instead of both up and down. */
div[class^="speech-bubble-holder"]>div:nth-of-type(2)>div {
    margin-top: auto; margin-bottom: auto;
}



</style>
<script src="https://unpkg.com/compromise/builds/compromise.min.js"></script>
<script src="main.js"></script>
<script>
    var app = Elm.Main.fullscreen();
    app.ports.sentences.subscribe(function(text) {
        var output = nlp(text).sentences().list.map(function(x) { return x.out('text').trim(); });
        app.ports.receiveSentences.send(output);
    });
    app.ports.normalize.subscribe(function(text) {
        var output = nlp(text).out('root');
        app.ports.receiveNormalize.send(output);
    });

    // Not sure if this helps at all?
    var audioCache = {};
    for (var i = 0; i < 120; i++) {
        var path = "assets/sfx/chomp" + i + ".mp3"
        audioCache[path] = new Audio(path);
        audioCache[path].load();
    }

    app.ports.playOneOf.subscribe(function(paths) {
        var path = paths[Math.floor(Math.random() * paths.length)];
        if (!audioCache[path]) {
            audioCache[path] = new Audio(path);
        }
        audioCache[path].play();
    });
</script>
