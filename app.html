<meta charset="utf-8">
<div id="main"></div>
<link href="https://fonts.googleapis.com/css?family=Lato:400,900" rel="stylesheet">
<style>
body { background-color: rgb(125, 119, 168); }

.rattle { animation: rattle 0.82s step-end both; }
@keyframes rattle {
  10%, 90% { transform: translate3d(-1px, 0, 0); }
  20%, 80% { transform: translate3d(2px, 0, 0); }
  30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
  40%, 60% { transform: translate3d(4px, 0, 0); }
}

.hatch { animation: hatch 1s ease-out both; }
@keyframes hatch {
  from { filter: brightness(800%); }
  to { filter: brightness(100%); }
}

.pet .wiggly { animation: pet 0.1s ease-out both; }
@keyframes pet {
  from { transform: translatey(4px); }
  to { transform: none; }
}

.wiggly { animation: up4px 0.8s alternate infinite steps(2, end); }
@keyframes up4px { to { transform: translatey(-4px);} }

/* This selects the *parent* of the speech bubble div (which is a "helper"
   div that style-elments injects, hence this rule's presence in HTML-land).
   It sets that elements' margin rules so that the speech bubble overflows
   *downward* instead of both up and down. */
div[class^="speech-bubble-holder"]>div:nth-of-type(2)>div {
    margin-top: auto; margin-bottom: auto;
}

</style>
<script src="https://unpkg.com/compromise/builds/compromise.min.js"></script>
<script src="main.js"></script>
<script>
    var app = Elm.Main.fullscreen();
    app.ports.sentences.subscribe(function(text) {
        var output = nlp(text).sentences().list.map(function(x) { return x.out('text').trim(); });
        app.ports.receiveSentences.send(output);
    });
    app.ports.normalize.subscribe(function(text) {
        var output = nlp(text).out('root');
        app.ports.receiveNormalize.send(output);
    });

    // Not sure if this helps at all?
    var audioCache = {};
    for (var i = 0; i < 120; i++) {
        var path = 'assets/sfx/chomp' + i + '.mp3'
        audioCache[path] = new Audio(path);
        audioCache[path].load();
    }

    app.ports.playOneOf.subscribe(function(paths) {
        var path = paths[Math.floor(Math.random() * paths.length)];
        if (!audioCache[path]) {
            audioCache[path] = new Audio(path);
        }
        audioCache[path].play();
    });

    // Animation.trigger
    app.ports.trigger.subscribe(function(className) {
        var critter = document.getElementById('critter');
        critter.classList.add(className);
        critter.addEventListener('animationend', function() {
            critter.classList.remove(className);
        }, false);
    });
</script>
